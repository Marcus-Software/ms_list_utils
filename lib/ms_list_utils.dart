library ms_list_utils;

import './functions/functions.dart' as fn;

export './functions/functions.dart';

extension MsListUtils<V> on List<V> {
  /// Returns first element in array, if it's empty returns null.
  V? get firstOrNull => fn.firstOrNull(this);

  /// Returns last element in array, if it's empty returns null.
  V? get lastOrNull => fn.lastOrNull(this);

  /// Elements that you have in this and do not have in [other].
  /// Short operator of the [diff] function
  List<V> operator -(List<V> other) => fn.diff(this, other);

  /// Returns new list with items generated around [list]
  /// ```dart
  /// final list = ['😁','😒','😊'];
  /// final newList = addAround(list, (index,previous,next) => '🍨');
  /// print(newList);//['🍨','😁','🍨','😒','🍨','😊','🍨']
  /// ```
  List<V> addAround(fn.Generator<V> generate) => fn.addAround(this, generate);

  /// Returns new list with items generated between list.
  List<V> addBetween(fn.Generator<V> generate) => fn.addBetween(this, generate);

  /// Check if contains all elements in the [other] list.
  bool containsAll(Iterable<V> other) => fn.containsAll(this, other);

  /// Check if contains any elements in the [other] list.
  bool containsAny(Iterable<V> other) => fn.containsAny(this, other);

  /// Check if [atLeast] elements in the [other] list.
  bool containsAtLeast(Iterable<V> other, int atLeast) =>
      fn.containsAtLeast(this, other, atLeast);

  /// Count of items that hit both lists
  int containsHits(Iterable<V> other) => fn.containsHits(this, other);

  /// Elements that you have in this and do not have in [other].
  List<V> diff(List<V> other) => fn.diff(this, other);

  /// Returns the first element that satisfies the test if there isn't one add a new one and return it.
  V firstWhereOrAdd(bool Function(V element) test, fn.OrAdd<V> orAdd) =>
      fn.firstWhereOrAdd(this, test, orAdd);

  /// Flatting a list that has other lists inside other lists inside other lists ... recursive
  /// ```dart
  /// final multiList = ["Marcus", "Ana", "Emanuel",["PC", "Xbox", "Books"]];
  /// multiList.flat();// ["Marcus", "Ana", "Emanuel", "PC", "Xbox", "Books"]
  /// ```
  List<V> flat() => fn.flat(this);

  /// Common elements between this list and [other]
  ///
  /// In set theory, the intersection of a collection of sets is the set that
  /// contains their shared elements. Given two sets, A = {2, 3, 4, 7, 10} and B = {1, 3, 5, 7, 9}, their intersection is as follows:
  /// A ∩ B = {3, 7}
  List<V> intersection(List<V> other) => fn.intersection(this, other);

  /// Returns a true value if element is the first in the list.
  bool isFirst(V element) => fn.isFirst(this, element);

  /// Returns a true value if index is the first in the list.
  bool isFirstIndex(int index) => fn.isFirstIndex(this, index);

  ///  Returns a true value if element is the last in the list.
  bool isLast(V element) => fn.isLast(this, element);

  ///  Returns a true value if index is the last in the list.
  bool isLastIndex(int index) => fn.isLastIndex(this, index);

  /// It joins all elements of the list with one separator and for the last iteration a different separator.
  String joinLast([String separator = '', String? last]) =>
      fn.join(this, separator, last);

  /// Returns the last element that satisfies the test if there isn't one add a new one and return it.
  V lastWhereOrAdd(bool Function(V element) test, fn.OrAdd<V> orAdd) =>
      fn.lastWhereOrAdd(this, test, orAdd);

  /// Returns an element following the index, if out of bounds returns null.
  V? next(int index) => fn.next(this, index);

  /// Returns a preceding element in the index, if out of bounds returns null.
  V? previous(int index) => fn.previous(this, index);

  /// Returns a Map with keys that's generated by generator.
  Map<K, V> toMap<K>(fn.GeneratorKey<V, K> generateKey) =>
      fn.toMap(this, generateKey);

  /// Creates a stream with the items in the list.
  Stream<V> toStream([Duration? interval]) => fn.toStream(this, interval);
}
