import '../functions/functions.dart' as fn;

extension MsIterableUtils<V> on Iterable<V> {
  /// Returns first element in array, if it's empty returns null.
  V? get firstOrNull => fn.firstOrNull<V>(this);

  /// Returns last element in array, if it's empty returns null.
  V? get lastOrNull => fn.lastOrNull<V>(this);

  /// Elements that you have in this and do not have in [other].
  /// Short operator of the [diff] function
  Iterable<V> operator -(Iterable<V> other) => fn.diff(this, other);

  /// Check if contains all elements in the [other] list.
  bool containsAll(Iterable<V> other) => fn.containsAll(this, other);

  /// Check if contains any elements in the [other] list.
  bool containsAny(Iterable<V> other) => fn.containsAny(this, other);

  /// Check if [atLeast] elements in the [other] list.
  bool containsAtLeast(Iterable<V> other, int atLeast) =>
      fn.containsAtLeast(this, other, atLeast);

  /// Count of items that hit both lists
  int containsHits(Iterable<V> other) => fn.containsHits(this, other);

  /// Elements that you have in this and do not have in [other].
  List<V> diff(List<V> other) => fn.diff<V>(this, other);

  /// Return first element that's pass in [test] or null if not found.
  V? firstWhereOrNull(bool Function(V) test) =>
      fn.firstWhereOrNull<V>(this, test);

  /// Flatting a list that has other lists inside other lists inside other lists ... recursive
  /// ```dart
  /// final multiList = ["Marcus", "Ana", "Emanuel",["PC", "Xbox", "Books"]];
  /// multiList.flat();// ["Marcus", "Ana", "Emanuel", "PC", "Xbox", "Books"]
  /// ```
  List<V> flat() => fn.flat<V>(this);

  /// Common elements between this list and [other]
  ///
  /// In set theory, the intersection of a collection of sets is the set that
  /// contains their shared elements. Given two sets, A = {2, 3, 4, 7, 10} and B = {1, 3, 5, 7, 9}, their intersection is as follows:
  /// A ∩ B = {3, 7}
  Iterable<V> intersection(Iterable<V> other) =>
      fn.intersection<V>(this, other);

  /// Returns a true value if element is the first in the list.
  bool isFirst(V element) => fn.isFirst<V>(this, element);

  /// Returns a true value if index is the first in the list.
  bool isFirstIndex(int index) => fn.isFirstIndex<V>(this, index);

  ///  Returns a true value if element is the last in the list.
  bool isLast(V element) => fn.isLast<V>(this, element);

  ///  Returns a true value if index is the last in the list.
  bool isLastIndex(int index) => fn.isLastIndex<V>(this, index);

  /// It joins all elements of the list with one separator and for the last iteration a different separator.
  String joinLast([String separator = '', String? last]) =>
      fn.join<V>(this, separator, last);

  /// Return last element that's pass in [test] or null if not found.
  V? lastWhereOrNull(bool Function(V) test) =>
      fn.lastWhereOrNull<V>(this, test);

  /// Returns a Map with keys that's generated by generator.
  Map<K, V> toMap<K>(fn.GeneratorKey<V, K> generateKey) =>
      fn.toMap(this, generateKey);

  /// Creates a stream with the items in the list.
  Stream<V> toStream([Duration? interval]) => fn.toStream(this, interval);

  /// Groups the items into sub-lists of the size given in [sizeEachList]
  ///
  /// Example:
  /// ```dart
  /// final List source = [
  ///   'Dying Light 1',
  ///   'Dying Light 2',
  ///   'Dead Island 1',
  ///   'Dead Island Riptide',
  ///   'GTA IV',
  ///   'Batman: Arkham City GOTY',
  ///   'F.E.A.R. 1',
  ///   'F.E.A.R. 2',
  ///   'F.E.A.R. 3',
  /// ];
  /// final groupedList3 = groupBySize(source, 3);
  /// print(groupedList3.toString());
  /// //[
  /// // [Dying Light 1, Dying Light 2, Dead Island 1],
  /// // [Dead Island Riptide, GTA IV, Batman: Arkham City GOTY],
  /// // [F.E.A.R. 1, F.E.A.R. 2, F.E.A.R. 3]
  /// //]
  /// ```
  Iterable<Iterable<V>> groupBySize(int sizeEachList) =>
      fn.groupBySize<V>(this, sizeEachList);

  ///Iterable elements with support async function and runs it's in [parallels]
  Future<void> forEachAsync(Future<void> Function(V element) forEach,
          [int parallels = 1]) =>
      fn.forEachAsync(this, forEach, parallels);

  /// Iterable elements with support async and emits each [forEach] async ends.
  Stream<V> mapAsStream(Future<V> Function(V element) forEach,
          [int parallels = 1]) =>
      fn.mapAsStream(this, forEach, parallels);
}
